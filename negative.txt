import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.*;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

public class InvalidPainFileGenerator {

    public static void main(String[] args) throws Exception {
        String inputPath = "valid_template.xml";
        String outputDir = "output/";
        String reasonCode = "FF02"; // Change to required code
        String versionLabel = "PAIN1"; // e.g., PAIN1, PAIN8

        generateInvalidFile(inputPath, outputDir, reasonCode, versionLabel);
    }

    public static void generateInvalidFile(String inputPath, String outputDir, String reasonCode, String versionLabel) throws Exception {
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        dbFactory.setNamespaceAware(false);
        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
        Document doc = dBuilder.parse(new File(inputPath));

        switch (reasonCode) {
            case "FF02":
                if (versionLabel.startsWith("PAIN1")) {
                    insertInvalidTag(doc, "/Document/CstmrCdtTrfInitn/PmtInf/CdtTrfTxInf");
                    removeRequiredParent(doc, "/Document/CstmrCdtTrfInitn/PmtInf");
                }
                break;
            case "RR10":
                insertInvalidCharacter(doc, "/Document/CstmrCdtTrfInitn/PmtInf/PmtInfId");
                break;
            case "DT02":
                setInvalidCreationDate(doc, "/Document/CstmrCdtTrfInitn/GrpHdr/CreDtTm");
                break;
            case "AM05":
                generateDuplicateFile(inputPath, outputDir); // handled in another method
                return;
            case "TD02":
                generateMalformedFile(outputDir + "TD02_InvalidFile.xml");
                return;
            case "DU02":
                insertDuplicateBatch(doc, versionLabel);
                break;
            default:
                System.out.println("Unknown reason code");
        }

        writeXml(doc, outputDir + reasonCode + "_InvalidFile.xml");
    }

    private static void insertInvalidTag(Document doc, String xpathExpr) throws Exception {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node parent = (Node) xpath.evaluate(xpathExpr, doc, XPathConstants.NODE);
        if (parent != null) {
            Element invalidTag = doc.createElement("InvalidTag");
            invalidTag.setTextContent("ThisTagIsInvalid");
            parent.appendChild(invalidTag);
        }
    }

    private static void removeRequiredParent(Document doc, String xpathExpr) throws Exception {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node parent = (Node) xpath.evaluate(xpathExpr, doc, XPathConstants.NODE);
        if (parent != null && parent.getParentNode() != null) {
            parent.getParentNode().removeChild(parent); // Remove <PmtInf>
        }
    }

    private static void insertInvalidCharacter(Document doc, String xpathExpr) throws Exception {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node node = (Node) xpath.evaluate(xpathExpr, doc, XPathConstants.NODE);
        if (node != null) {
            node.setTextContent("Invalid&Name"); // '&' is reserved XML character
        }
    }

    private static void setInvalidCreationDate(Document doc, String xpathExpr) throws Exception {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node dateNode = (Node) xpath.evaluate(xpathExpr, doc, XPathConstants.NODE);
        if (dateNode != null) {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
            Date tooOld = new Date(System.currentTimeMillis() - (35L * 24 * 60 * 60 * 1000)); // 35 days old
            dateNode.setTextContent(sdf.format(tooOld));
        }
    }

    private static void generateDuplicateFile(String inputPath, String outputDir) throws Exception {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();

        Document doc1 = db.parse(new File(inputPath));
        Document doc2 = db.parse(new File(inputPath));

        // Same MsgId, PmtInfId, etc. to simulate duplicate file scenario
        writeXml(doc1, outputDir + "AM05_DuplicateFile1.xml");
        writeXml(doc2, outputDir + "AM05_DuplicateFile2.xml");
    }

    private static void generateMalformedFile(String outputPath) throws Exception {
        String brokenXml = "<Document><BadRoot><MissingEnd>";
        try (java.io.FileWriter fw = new java.io.FileWriter(outputPath)) {
            fw.write(brokenXml);
        }
    }

    private static void insertDuplicateBatch(Document doc, String versionLabel) throws Exception {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node originalBatch = (Node) xpath.evaluate("/Document/CstmrCdtTrfInitn/PmtInf", doc, XPathConstants.NODE);
        if (originalBatch != null) {
            Node duplicate = originalBatch.cloneNode(true);
            doc.getDocumentElement().appendChild(duplicate);
        }
    }

    private static void writeXml(Document doc, String path) throws Exception {
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        Result output = new StreamResult(new File(path));
        Source input = new DOMSource(doc);
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        transformer.transform(input, output);
    }
}
