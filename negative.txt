import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.File;
import java.io.FileWriter;
import java.text.SimpleDateFormat;
import java.util.*;

///adesh

public class PainInvalidFileGenerator {

    public static void main(String[] args) throws Exception {
        List<String> reasonCodes = Arrays.asList("FF02", "RR10", "DT02", "AM05", "TD02", "DU02", "DT01", "RC01", "AC03", "AM01", "BE05");
        String inputPath = "template/pain.001.001.03.xml";
        String outputDir = "output/";
        String fileFormat = "pain.001.001.03";

        for (String code : reasonCodes) {
            generateInvalidFile(code, inputPath, outputDir, fileFormat);
        }
    }

    private static void generateInvalidFile(String reasonCode, String inputPath, String outputDir, String fileFormat) throws Exception {
        switch (reasonCode) {
            case "FF02":
                if (fileFormat.equals("pain.001.001.03")) {
                    createMissingParentTagFile(reasonCode, inputPath, outputDir);
                }
                break;
            case "RR10":
                if (fileFormat.equals("pain.001.001.03")) {
                    createReservedCharFile(reasonCode, inputPath, outputDir);
                }
                break;
            case "DT02":
                if (fileFormat.equals("pain.001.001.03")) {
                    createInvalidCreationDateFile(reasonCode, inputPath, outputDir);
                }
                break;
            case "AM05":
                if (fileFormat.equals("pain.001.001.03")) {
                    createDuplicateMsgIdFile(reasonCode, inputPath, outputDir);
                }
                break;
            case "TD02":
                if (fileFormat.equals("pain.001.001.03")) {
                    createUnreadableXmlFile(reasonCode, outputDir);
                }
                break;
            case "DU02":
                if (fileFormat.equals("pain.001.001.03")) {
                    createDuplicateBatchIdFile(reasonCode, inputPath, outputDir);
                }
                break;
            default:
                System.out.println("Reason code " + reasonCode + " not supported for file format " + fileFormat);
        }
    }

    private static void createMissingParentTagFile(String reasonCode, String inputPath, String outputDir) throws Exception {
        File file = new File(outputDir + reasonCode + "_MissingParent.xml");
        try (FileWriter writer = new FileWriter(file)) {
            writer.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                    "<Document xmlns=\"urn:iso:std:iso:20022:tech:xsd:pain.001.001.03\">\n" +
                    "    <CstmrCdtTrfInitn>\n" +
                    "        <GrpHdr>\n" +
                    "            <MsgId>MSG-" + reasonCode + "</MsgId>\n" +
                    "        </GrpHdr>\n" +
                    "        <!-- Missing PmtInf Tag here -->\n" +
                    "    </CstmrCdtTrfInitn>\n" +
                    "</Document>");
        }
    }

    private static void createReservedCharFile(String reasonCode, String inputPath, String outputDir) throws Exception {
        Document doc = getDocument(inputPath);
        Node msgIdNode = (Node) javax.xml.xpath.XPathFactory.newInstance().newXPath()
                .evaluate("//MsgId", doc, javax.xml.xpath.XPathConstants.NODE);
        msgIdNode.setTextContent("INVALID&MSG<>");
        saveDocument(doc, new File(outputDir + reasonCode + "_ReservedChars.xml"));
    }

    private static void createInvalidCreationDateFile(String reasonCode, String inputPath, String outputDir) throws Exception {
        Document doc = getDocument(inputPath);
        Node creDtTm = (Node) javax.xml.xpath.XPathFactory.newInstance().newXPath()
                .evaluate("//CreDtTm", doc, javax.xml.xpath.XPathConstants.NODE);
        Calendar calendar = Calendar.getInstance();
        if (new Random().nextBoolean()) {
            calendar.add(Calendar.DATE, -40);
        } else {
            calendar.add(Calendar.HOUR, 30);
        }
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        creDtTm.setTextContent(sdf.format(calendar.getTime()));
        saveDocument(doc, new File(outputDir + reasonCode + "_InvalidDate.xml"));
    }

    private static void createDuplicateMsgIdFile(String reasonCode, String inputPath, String outputDir) throws Exception {
        Document doc = getDocument(inputPath);
        Node msgIdNode = (Node) javax.xml.xpath.XPathFactory.newInstance().newXPath()
                .evaluate("//MsgId", doc, javax.xml.xpath.XPathConstants.NODE);
        String duplicateId = "DUPLICATE-MSG-ID-AM05";
        msgIdNode.setTextContent(duplicateId);
        saveDocument(doc, new File(outputDir + reasonCode + "_1.xml"));
        saveDocument(doc, new File(outputDir + reasonCode + "_2.xml"));
    }

    private static void createUnreadableXmlFile(String reasonCode, String outputDir) throws Exception {
        try (FileWriter writer = new FileWriter(new File(outputDir + reasonCode + "_Invalid.xml"))) {
            writer.write("<Doc><Invalid<<>>><</Tag></Doc>");
        }
    }

    private static void createDuplicateBatchIdFile(String reasonCode, String inputPath, String outputDir) throws Exception {
        Document doc = getDocument(inputPath);
        NodeList pmtInfs = doc.getElementsByTagNameNS("urn:iso:std:iso:20022:tech:xsd:pain.001.001.03", "PmtInf");
        if (pmtInfs.getLength() >= 1) {
            Node duplicate = pmtInfs.item(0).cloneNode(true);
            pmtInfs.item(0).getParentNode().appendChild(duplicate);
        }
        saveDocument(doc, new File(outputDir + reasonCode + "_DuplicateBatch.xml"));
    }

    private static Document getDocument(String filePath) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(new File(filePath));
    }

    private static void saveDocument(Document doc, File outFile) throws Exception {
        Transformer transformer = TransformerFactory.newInstance().newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        transformer.transform(new DOMSource(doc), new StreamResult(outFile));
    }
}
